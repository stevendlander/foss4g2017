<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>FOSS4G Boston 2017</title>

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/solarized.css">

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section data-markdown id="title">
                    <textarea data-template>
                        ## Containerizing your geospatial applications with Docker
                        #### FOSS4G Boston 2017

                        Note:
                        Hello everyone and thanks for attending my presentation
                        on geospatial containers and how they can help you
                        develop, deploy, and manage applications more easily.
                        In this talk I hope to make clear why containers are
                        popular in software development but also underscore the
                        ways in which Docker and programs like it can reduce
                        rework and cut mundane tasks from your workflows.
                        Let's begin.
                    </textarea>
                </section>
                <section data-markdown data-separator="---" id="intro">
                    <textarea data-template>
                        ### About me

                        * Software Architect @ [Reinventing Geospatial, Inc.
                        (RG<span style="text-transform:
                            lowercase;">i</span>)](http://rgi-corp.com)
                        * Level 20 CLI Wizard (_can cast 9th level GDAL commands_)
                        * Geospatial API development in Java, Android, Javascript
                        * My [GitHub](https://github.com/stevendlander) and
                        [GitLab](https://gitlab.com/stevendlander)
                        * See my
                        [previous](https://github.com/GitHubRGI/FOSS4G-Seoul-2015/blob/master/Friday/1125-1150_BuildingCI/BuildingCI.pdf)
                        [talks](https://github.com/GitHubRGI/FOSS4G-Seoul-2015/blob/master/Thursday/1125-1150_OGCGeoPackageInPractice/OGCGeoPackageInPractice.pdf)
                        from FOSS4G Seoul 2015

                        Note:
                        My name is Steve Lander, and I have been in the
                        geospatial domain for going on 7 years now in various
                        roles, most recently as a project technical lead and
                        architect.  Applied research is a good way of
                        describing the sorts of projects I have been working on
                        recently, for example, API development for tile
                        caching and storage. I also happen to dabble in the
                        dart art of GDAL command line utilities.
                        ---
                        ### Outline

                        * Why even use containers? How will they benefit me?
                        * Ok...what are some ways I can make one?  How do I get
                        started?
                        * What are some more advanced topics?

                        Note:
                        What will we be discussing today: How are containers
                        fundamentally different from other technologies and why
                        is that a good thing?  What are some easy ways to get
                        started making containers that help me do my job?  And
                        finally, for those of you well-versed in Docker and
                        similar programs already, what are some advanced topics
                        to take you further.
                    </textarea>
                </section>
                <section data-markdown data-separator="---" id="use_cases">
                    <textarea data-template>
                        ## Relevant use cases

                        Note:
                        From here on, I am going to assume Docker is your tool
                        of choice for manipulating containers.  There are other
                        options such as Vagrant, however, should you be
                        interested in other offerings.
                        ---
                        ### A build environment

                        Build your applications consistently and reliably

                        ```Dockerfile
                        # Start from this base linux image...
                        FROM debian:8.9 # aka "jessie", but be specific!

                        # Install this software to the container from a pkg manager
                        RUN apt-get update -y &amp;&amp; apt-get install -y \
                            curl \
                            wget \
                            openjdk-8

                        # Customize my environment they way I need it
                        ENV JAVA_HOME /usr/bin/java
                        ```

                        Note:
                        * Containers work well as build environments.  You might
                        not even be aware they were working if you have ever
                        used TravisCI on an open source project.
                        * Your Dockerfile is a recipe on how to make the same
                        thing over and over exactly the same way, so it pays to
                        ensure specific versions of software are used instead
                        of the latest ones.  You wouldn't want updates to your
                        base OS breaking your software unexpectedly!
                        ---
                        ### A build environment (cont'd)

                        Avoid polluting your desktop environment with
                        dependencies you don't need outside of your development
                        environment

                        ```Dockerfile
                        FROM debian:8.9

                        # Move to a new folder to work in, creating it if necessary
                        WORKDIR /workspace

                        # I install so many packages, it isn't worth listing them all
                        COPY install_packages.sh install_packages.sh
                        RUN /bin/bash install_packages.sh

                        # Build GDAL from scratch (let's say I need MrSID)...
                        COPY gdal_build_script_of_doom.sh gdal_build_script_of_doom.sh
                        RUN /bin/bash gdal_build_script_of_doom.sh
                        ```

                        Note:
                        Maybe your program needs tons of python libraries that
                        you would not otherwise use on other projects.  Perhaps
                        you build a library like GDAL from source to get
                        additional driver support not otherwise provided due to
                        licensing restrictions along with some SWIG bindings to
                        other languages. In either of these cases the computer
                        you rely on to do your job stays neat and tidy, and
                        when you don't need the dependencies, simply delete
                        your container.
                        ---
                        ### A build environment (cont'd)

                        Reduce the time it takes for other people to build,
                        run, test, and contribute to your project

                        ```Dockerfile
                        # A Docker container with my code
                        FROM debian:8.9

                        WORKDIR /workspace
                        RUN git clone https://github.com/stevendlander/foss4g2017 \
                            &amp;&amp; cd foss4g2017

                        COPY helperScript.sh helperScript.sh

                        EXPOSE 8080 # My web service port
                        EXPOSE 8000 # Debugging port
                        ENV JPDA_ADDRESS 8000
                        ENV JPDA_TRANSPORT dt_socket
                        ```

                        Note:
                        Create a container for other developers to be dropped
                        into a command prompt, ready to start debugging from
                        their IDE over HTTP.  If you ever have had to spend
                        days getting your environment configured, I hope you
                        can appreciate how much time and frustration this can
                        save you.
                        ---
                        ### Local builds

                        Just use a simple container to build your code and
                        artifacts

                        ```bash
                        docker run --rm \
                            -v /your/code:/workspace \
                            --entrypoint cd /workspace &amp;&amp; mvn build \
                            maven:3.5-jdk-7
                        ```
                        Note:
                        This example will mount your code directory to the
                        Docker container workspace folder, then run a maven
                        build command within it.  Once it is done, the
                        container will be cleaned up.  Since you mounted your
                        code directory to the container, all the files it
                        created during your build will stick around on YOUR
                        file system.
                        ---
                        ### Continuous integration 

                        * Create a build-ready container with static analysis
                        tools, security scan tools, code coverage libraries
                        * Save the container with a friendly name
                        (_my_java_app:1.0_) and publish it to
                        [DockerHub](https://hub.docker.com)
                        ---
                        ### Continuous integration (cont'd :D)

                        Source that container into your .gitlab-ci.yml file

                        ```yaml
                        test:my_test_phase:
                            image: my_java_app:1.0
                            script:
                                - ./gradlew build
                                - ./gradlew javadocs
                        ```

                        Note:
                        Use your new container to automate how you build your
                        application in the future. Future container versions
                        (maybe you forgot a library?) can be updated by
                        changing to 1.0 to a 1.1.
                        ---
                        ### A work environment
                    </textarea>
                </section>
                <section data-markdown data-separator="---" id="creation">
                    <textarea data-template>
                        ### Container creation
                        ---
                        ### 
                    </textarea>
                </section>
                <section data-markdown data-separator="---" id="advanced">
                    <textarea data-template>
                        ### 12 factor applications
                        ---
                        ### Alpine
                        ---
                        ### Orchestration
                        ---
                        ### Tips
                        ---
                        ### Gripes &gt;_&lt;
                        
                        * Build environment containers typically run as _root_
                        which a linux host will honor
                        * Passing credentials as environment variables is
                        convenient but insecure, and solutions are complicated
                        to implement
                        Dockerfiles can and do get crazy if your build is
                        equally crazy.  Some people prefer having one
                        monolithic Dockerfile with no dependent scripts, which
                        is completely understandable.  Others would rather a
                        brief Dockerfile that pushes the heavy lifting to a
                        shell script that gets maintained instead.
                    </textarea>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info about config & dependencies:
            // - https://github.com/hakimel/reveal.js#configuration
            // - https://github.com/hakimel/reveal.js#dependencies
            Reveal.initialize({
                dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                ]
            });
        </script>
    </body>
</html>
